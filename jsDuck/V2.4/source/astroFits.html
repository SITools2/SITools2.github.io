<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// Generated by CoffeeScript 1.4.0
(function() {
	var BinaryTable, CompressedImage, DataUnit, Decompress, ASTROFITS, File, HDU, Header, HeaderVerify, Image, ImageUtils, Module, Table, Tabular, moduleKeywords, __indexOf = [].indexOf
			|| function(item) {
				for (var i = 0, l = this.length; i &lt; l; i++) {
					if (i in this &amp;&amp; this[i] === item)
						return i;
				}
				return -1;
			}, __hasProp = {}.hasOwnProperty, __extends = function(child,
			parent) {
		for (var key in parent) {
			if (__hasProp.call(parent, key))
				child[key] = parent[key];
		}
		function ctor() {
			this.constructor = child;
		}
		ctor.prototype = parent.prototype;
		child.prototype = new ctor();
		child.__super__ = parent.prototype;
		return child;
	}, __slice = [].slice, __bind = function(fn, me) {
		return function() {
			return fn.apply(me, arguments);
		};
	};

	if (this.astro == null) {
		this.astro = {};
	}

	ASTROFITS = {};

	ASTROFITS.version = '0.2.3';

	this.astro.ASTROFITS = ASTROFITS;

	moduleKeywords = ['included', 'extended'];

	Module = (function() {

		function Module() {
		}

		Module.include = function(obj) {
			var key, value, _ref;
			if (!obj) {
				throw 'include(obj) requires obj';
			}
			for (key in obj) {
				value = obj[key];
				if (__indexOf.call(moduleKeywords, key) &lt; 0) {
					this.prototype[key] = value;
				}
			}
			if ((_ref = obj.included) != null) {
				_ref.apply(this);
			}
			return this;
		};

		Module.extend = function(obj) {
			var key, value, _ref;
			if (!obj) {
				throw 'extend(obj) requires obj';
			}
			for (key in obj) {
				value = obj[key];
				if (__indexOf.call(moduleKeywords, key) &lt; 0) {
					this[key] = value;
				}
			}
			if ((_ref = obj.extended) != null) {
				_ref.apply(this);
			}
			return this;
		};

		Module.proxy = function(func) {
			var _this = this;
			return function() {
				return func.apply(_this, arguments);
			};
		};

		Module.prototype.proxy = function(func) {
			var _this = this;
			return function() {
				return func.apply(_this, arguments);
			};
		};

		return Module;

	})();

	this.astro.ASTROFITS.Module = Module;

	DataUnit = (function(_super) {

		__extends(DataUnit, _super);

		function DataUnit(view, header) {
			this.view = view;
			this.begin = this.current = view.tell();
			this.length = void 0;
		}

		return DataUnit;

	})(Module);

	this.astro.ASTROFITS.DataUnit = DataUnit;

	HeaderVerify = {
		verifyOrder : function(keyword, order) {
			if (order !== this.cardIndex) {
				return console.warn(&quot;&quot; + keyword + &quot; should appear at index &quot;
						+ this.cardIndex + &quot; in the ASTROFITS header&quot;);
			}
		},
		verifyBetween : function(keyword, value, lower, upper) {
			if (!(value &gt;= lower &amp;&amp; value &lt;= upper)) {
				throw &quot;The &quot; + keyword + &quot; value of &quot; + value
						+ &quot; is not between &quot; + lower + &quot; and &quot; + upper;
			}
		},
		verifyBoolean : function(value) {
			if (value === &quot;T&quot;) {
				return true;
			} else {
				return false;
			}
		},
		Functions : {
			SIMPLE : function() {
				var args, value;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				value = arguments[0];
				this.primary = true;
				this.verifyOrder(&quot;SIMPLE&quot;, 0);
				return this.verifyBoolean(value);
			},
			XTENSION : function() {
				var args, value;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				value = arguments[0];
				this.extension = true;
				this.extensionType = value;
				this.verifyOrder(&quot;XTENSION&quot;, 0);
				return value;
			},
			BITPIX : function() {
				var args, key, value;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;BITPIX&quot;;
				value = parseInt(arguments[0]);
				this.verifyOrder(key, 1);
				if (value !== 8 &amp;&amp; value !== 16 &amp;&amp; value !== 32 &amp;&amp; value !== 64
						&amp;&amp; value !== (-32) &amp;&amp; value !== (-64)) {
					throw &quot;&quot; + key + &quot; value &quot; + value + &quot; is not permitted&quot;;
				}
				return value;
			},
			NAXIS : function() {
				var args, array, key, required, value, _ref;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;NAXIS&quot;;
				value = parseInt(arguments[0]);
				array = arguments[1];
				if (!array) {
					this.verifyOrder(key, 2);
					this.verifyBetween(key, value, 0, 999);
					if (this.isExtension()) {
						if ((_ref = this.extensionType) === &quot;TABLE&quot;
								|| _ref === &quot;BINTABLE&quot;) {
							required = 2;
							if (value !== required) {
								throw &quot;&quot; + key + &quot; must be &quot; + required
										+ &quot; for TABLE and BINTABLE extensions&quot;;
							}
						}
					}
				}
				return value;
			},
			PCOUNT : function() {
				var args, key, order, required, value, _ref;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;PCOUNT&quot;;
				value = parseInt(arguments[0]);
				order = 1 + 1 + 1 + this[&quot;NAXIS&quot;];
				this.verifyOrder(key, order);
				if (this.isExtension()) {
					if ((_ref = this.extensionType) === &quot;IMAGE&quot;
							|| _ref === &quot;TABLE&quot;) {
						required = 0;
						if (value !== required) {
							throw &quot;&quot; + key + &quot; must be &quot; + required
									+ &quot; for the &quot; + this.extensionType
									+ &quot; extensions&quot;;
						}
					}
				}
				return value;
			},
			GCOUNT : function() {
				var args, key, order, required, value, _ref;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;GCOUNT&quot;;
				value = parseInt(arguments[0]);
				order = 1 + 1 + 1 + this[&quot;NAXIS&quot;] + 1;
				this.verifyOrder(key, order);
				if (this.isExtension()) {
					if ((_ref = this.extensionType) === &quot;IMAGE&quot;
							|| _ref === &quot;TABLE&quot; || _ref === &quot;BINTABLE&quot;) {
						required = 1;
						if (value !== required) {
							throw &quot;&quot; + key + &quot; must be &quot; + required
									+ &quot; for the &quot; + this.extensionType
									+ &quot; extensions&quot;;
						}
					}
				}
				return value;
			},
			EXTEND : function() {
				var args, key, value;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;EXTEND&quot;;
				value = arguments[0];
				if (!this.isPrimary()) {
					throw &quot;&quot; + key + &quot; must only appear in the primary header&quot;;
				}
				return this.verifyBoolean(value);
			},
			BSCALE : function() {
				var args;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				return parseFloat(arguments[0]);
			},
			BZERO : function() {
				var args;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				return parseFloat(arguments[0]);
			},
			BLANK : function() {
				var args, key, value;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;BLANK&quot;;
				value = arguments[0];
				// if (!(this[&quot;BITPIX&quot;] &gt; 0)) {
				// throw &quot;&quot; + key + &quot; is not to be used for BITPIX = &quot; +
				// this['BITPIX'];
				// }
				return parseInt(value);
			},
			DATAMIN : function() {
				var args;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				return parseFloat(arguments[0]);
			},
			DATAMAX : function() {
				var args;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				return parseFloat(arguments[0]);
			},
			EXTVER : function() {
				var args, key, value;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;EXTVER&quot;;
				value = arguments[0];
				value = parseInt(value);
				return value;
			},
			EXTLEVEL : function() {
				var args, key, value;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;EXTLEVEL&quot;;
				value = arguments[0];
				value = parseInt(value);
				return value;
			},
			TFIELDS : function() {
				var args, key, value;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;TFIELDS&quot;;
				value = arguments[0];
				value = parseInt(value);
				this.verifyBetween(key, value, 0, 999);
				return value;
			},
			TBCOL : function() {
				var args, index, key, value;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;TBCOL&quot;;
				value = arguments[0];
				index = arguments[2];
				this.verifyBetween(key, index, 0, this[&quot;TFIELDS&quot;]);
				return value;
			},
			ZIMAGE : function() {
				var args, key, value;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;ZIMAGE&quot;;
				value = arguments[0];
				return this.verifyBoolean(value);
			},
			ZCMPTYPE : function() {
				var args, key, value;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;ZCMPTYPE&quot;;
				value = arguments[0];
				if (value !== 'GZIP_1' &amp;&amp; value !== 'RICE_1'
						&amp;&amp; value !== 'PLIO_1' &amp;&amp; value !== 'HCOMPRESS_1') {
					throw &quot;&quot; + key + &quot; value &quot; + value + &quot; is not permitted&quot;;
				}
				if (value !== 'RICE_1' &amp;&amp; value !== 'GZIP_1') {
					throw &quot;Compress type &quot; + value + &quot; is not yet implement&quot;;
				}
				return value;
			},
			ZBITPIX : function() {
				var args, key, value;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;ZBITPIX&quot;;
				value = parseInt(arguments[0]);
				if (value !== 8 &amp;&amp; value !== 16 &amp;&amp; value !== 32 &amp;&amp; value !== 64
						&amp;&amp; value !== (-32) &amp;&amp; value !== (-64)) {
					throw &quot;&quot; + key + &quot; value &quot; + value + &quot; is not permitted&quot;;
				}
				return value;
			},
			ZNAXIS : function() {
				var args, array, key, value;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;ZNAXIS&quot;;
				value = parseInt(arguments[0]);
				array = arguments[1];
				value = value;
				if (!array) {
					this.verifyBetween(key, value, 0, 999);
				}
				return value;
			},
			ZTILE : function() {
				var args, key;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;ZTILE&quot;;
				return parseInt(arguments[0]);
			},
			ZSIMPLE : function() {
				var args;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				if (arguments[0] === &quot;T&quot;) {
					return true;
				} else {
					return false;
				}
			},
			ZPCOUNT : function() {
				var args, key;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;ZPCOUNT&quot;;
				return parseInt(arguments[0]);
			},
			ZGCOUNT : function() {
				var args, key;
				args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
				key = &quot;ZGCOUNT&quot;;
				return parseInt(arguments[0]);
			}
		}
	};

	this.astro.ASTROFITS.HeaderVerify = HeaderVerify;

	Header = (function(_super) {

		__extends(Header, _super);

		Header.keywordPattern = /^([A-Z0-9_-]+)\s*=\s*(.*)/;

		Header.nonStringPattern = /([^\/]*)\s*\/*(.*)/;

		Header.stringPattern = /'(.*)'\s*\/*(.*)/;

		Header.arrayPattern = /([A-Za-z]+)(\d+)/;

		Header.include(HeaderVerify);

		function Header() {
			this.init = __bind(this.init, this);

			var method, name, _ref;
			this.primary = false;
			this.extension = false;
			this.verifyCard = {};
			_ref = this.Functions;
			for (name in _ref) {
				method = _ref[name];
				this.verifyCard[name] = this.proxy(method);
			}
			this.cards = {};
			this.cardIndex = 0;
		}

		Header.prototype.get = function(key) {
			if (this.contains(key)) {
				return this.cards[key];
			} else {
				return console.warn(&quot;Header does not contain the key &quot; + key);
			}
		};

		Header.prototype.getIndex = function(key) {
			if (this.contains(key)) {
				return this.cards[key][0];
			} else {
				return console.warn(&quot;Header does not contain the key &quot; + key);
			}
		};

		Header.prototype.getComment = function(key) {
			if (this.contains(key)) {
				if (this.cards[key][2] != null) {
					return this.cards[key][2];
				} else {
					return console.warn(&quot;&quot; + key
							+ &quot; does not contain a comment&quot;);
				}
			} else {
				return console.warn(&quot;Header does not contain the key &quot; + key);
			}
		};

		Header.prototype.getComments = function() {
			if (this.contains('COMMENT')) {
				return this.cards['COMMENT'];
			} else {
				return console
						.warn(&quot;Header does not contain any COMMENT fields&quot;);
			}
		};

		Header.prototype.getHistory = function() {
			if (this.contains('HISTORY')) {
				return this.cards['HISTORY'];
			} else {
				return console
						.warn(&quot;Header does not contain any HISTORY fields&quot;);
			}
		};

		Header.prototype.set = function(key, value, comment) {
			this.cards[key] = comment ? [this.cardIndex, value, comment] : [
					this.cardIndex, value];
			return this.cardIndex += 1;
		};

		Header.prototype.setComment = function(comment) {
			if (!this.contains(&quot;COMMENT&quot;)) {
				this.cards[&quot;COMMENT&quot;] = [];
				this.cardIndex += 1;
			}
			return this.cards[&quot;COMMENT&quot;].push(comment);
		};

		Header.prototype.setHistory = function(history) {
			if (!this.contains(&quot;HISTORY&quot;)) {
				this.cards[&quot;HISTORY&quot;] = [];
				this.cardIndex += 1;
			}
			return this.cards[&quot;HISTORY&quot;].push(history);
		};

		Header.prototype.contains = function(keyword) {
			return this.cards.hasOwnProperty(keyword);
		};

		Header.prototype.readCard = function(line) {
			var array, comment, index, key, keyToVerify, match, value, _ref, _ref1, _ref2, _ref3, _ref4;
			match = line.match(Header.keywordPattern);
			if (match == null) {
				return;
			}
			_ref = match.slice(1), key = _ref[0], value = _ref[1];
			if (key === &quot;COMMENT&quot; || key === &quot;HISTORY&quot;) {
				match[1] = value.trim();
			} else if (value[0] === &quot;'&quot;) {
				match = value.match(Header.stringPattern);
				match[1] = match[1].trim();
			} else {
				match = value.match(Header.nonStringPattern);
				match[1] = (_ref1 = match[1][0]) === &quot;T&quot; || _ref1 === &quot;F&quot;
						? match[1].trim()
						: parseFloat(match[1]);
			}
			match[2] = match[2].trim();
			_ref2 = match.slice(1), value = _ref2[0], comment = _ref2[1];
			keyToVerify = key;
			_ref3 = [false, void 0], array = _ref3[0], index = _ref3[1];
			match = key.match(Header.arrayPattern);
			if (match != null) {
				keyToVerify = match[1];
				_ref4 = [true, match[2]], array = _ref4[0], index = _ref4[1];
			}
			if (this.verifyCard.hasOwnProperty(keyToVerify)) {
				value = this.verifyCard[keyToVerify](value, array, index);
			}
			switch (key) {
				case &quot;COMMENT&quot; :
					return this.setComment(value);
				case &quot;HISTORY&quot; :
					return this.setHistory(value);
				default :
					this.set(key, value, comment);
					return this.__defineGetter__(key, function() {
								return this.cards[key][1];
							});
			}
		};

		Header.prototype.init = function(block) {
			var i, line, lineWidth, maxNumLines, numLines, _i, _ref, _results;
			lineWidth = 80;
			numLines = block.length / lineWidth;
			maxNumLines = 600;
			numLines = numLines &lt; maxNumLines ? numLines : maxNumLines;
			_results = [];
			for (i = _i = 0, _ref = numLines - 1; 0 &lt;= _ref
					? _i &lt;= _ref
					: _i &gt;= _ref; i = 0 &lt;= _ref ? ++_i : --_i) {
				line = block.slice(i * lineWidth, (i + 1) * lineWidth);
				_results.push(this.readCard(line));
			}
			return _results;
		};

		Header.prototype.hasDataUnit = function() {
			if (this[&quot;NAXIS&quot;] === 0) {
				return false;
			} else {
				return true;
			}
		};

		Header.prototype.isPrimary = function() {
			return this.primary;
		};

		Header.prototype.isExtension = function() {
			return this.extension;
		};

		return Header;

	})(Module);

	this.astro.ASTROFITS.Header = Header;

	ImageUtils = {
		initArray : function(arrayType) {
			return this.data = new arrayType(this.width * this.height);
		},
		getExtremes : function() {
			var index, max, min, value, _ref, _ref1;
			if ((this.min != null) &amp;&amp; (this.max != null)) {
				return [this.min, this.max];
			}
			index = this.data.length;
			while (index--) {
				value = this.data[index];
				if (isNaN(value)) {
					continue;
				}
				_ref = [value, value], min = _ref[0], max = _ref[1];
				break;
			}
			while (index--) {
				value = this.data[index];
				if (isNaN(value)) {
					continue;
				}
				if (value &lt; min) {
					min = value;
				}
				if (value &gt; max) {
					max = value;
				}
			}
			_ref1 = [min, max], this.min = _ref1[0], this.max = _ref1[1];
			return [this.min, this.max];
		},
		getPixel : function(x, y) {
			return this.data[y * this.width + x];
		}
	};

	this.astro.ASTROFITS.ImageUtils = ImageUtils;

	Image = (function(_super) {

		__extends(Image, _super);

		Image.include(ImageUtils);

		function Image(view, header) {
			var bitpix, i, naxis, _i, _this = this;
			Image.__super__.constructor.apply(this, arguments);
			naxis = header[&quot;NAXIS&quot;];
			bitpix = header[&quot;BITPIX&quot;];
			this.naxis = [];
			for (i = _i = 1; 1 &lt;= naxis ? _i &lt;= naxis : _i &gt;= naxis; i = 1 &lt;= naxis
					? ++_i
					: --_i) {
				this.naxis.push(header[&quot;NAXIS&quot; + i]);
			}
			this.width = header[&quot;NAXIS1&quot;];
			this.height = header[&quot;NAXIS2&quot;] || 1;
			this.bzero = header[&quot;BZERO&quot;] || 0;
			this.bscale = header[&quot;BSCALE&quot;] || 1;
			this.rowByteSize = this.width * Math.abs(bitpix) / 8;
			this.totalRowsRead = 0;
			this.length = this.naxis.reduce(function(a, b) {
						return a * b;
					}) * Math.abs(bitpix) / 8;
			this.data = void 0;
			this.frame = 0;
			switch (bitpix) {
				case 8 :
					if (this.bscale % 1 === 0) {
						this.arrayType = Uint8Array;
						this.accessor = function() {
							return _this.bzero + _this.bscale
									* _this.view.getUint8();
						};
					} else {
						this.arrayType = Float32Array;
						this.accessor = function() {
							return _this.bzero + _this.bscale
									* _this.view.getUint8();
						};
					}
					break;
				case 16 :
					if (this.bscale % 1 === 0) {
						this.arrayType = Int16Array;
						this.accessor = function() {
							return _this.bzero + _this.bscale
									* _this.view.getInt16();
						};
					} else {
						this.arrayType = Float32Array;
						this.accessor = function() {
							return _this.bzero + _this.bscale
									* _this.view.getInt16();
						};
					}
					break;
				case 32 :
					if (this.bscale % 1 === 0) {
						this.arrayType = Int32Array;
						this.accessor = function() {
							return _this.bzero + _this.bscale
									* _this.view.getUint32();
						};
					} else {
						this.arrayType = Float32Array;
						this.accessor = function() {
							return _this.bzero + _this.bscale
									* _this.view.getUint32();
						};
					}
					break;
				case 64 :
					this.arrayType = this.bscale % 1 === 0
							? Int32Array
							: Float32Array;
					console.warn(&quot;Unusual behaviour with 64 bit integers.&quot;);
					this.accessor = function() {
						var factor, highByte, lowByte, mod, value;
						highByte = Math.abs(_this.view.getInt32());
						lowByte = Math.abs(_this.view.getInt32());
						mod = highByte % 10;
						factor = mod ? -1 : 1;
						highByte -= mod;
						value = factor * ((highByte &lt;&lt; 32) | lowByte);
						return _this.bzero + _this.bscale * value;
					};
					break;
				case -32 :
					this.arrayType = Float32Array;
					this.accessor = function() {
						return _this.bzero + _this.bscale
								* _this.view.getFloat32();
					};
					break;
				case -64 :
					this.arrayType = Float64Array;
					this.accessor = function() {
						return _this.bzero + _this.bscale
								* _this.view.getFloat64();
					};
					break;
				default :
					throw &quot;Invalid BITPIX.&quot;;
			}
		}

		Image.prototype.getRow = function() {
			var i, _i, _ref;
			this.current = this.begin + this.totalRowsRead * this.rowByteSize;
			this.view.seek(this.current);
			for (i = _i = 0, _ref = this.width - 1; 0 &lt;= _ref
					? _i &lt;= _ref
					: _i &gt;= _ref; i = 0 &lt;= _ref ? ++_i : --_i) {
				this.data[this.width * this.rowsRead + i] = this.accessor();
			}
			this.rowsRead += 1;
			return this.totalRowsRead += 1;
		};

		Image.prototype.getFrame = function(frame) {
			var height;
			this.frame = frame != null ? frame : this.frame;
			if (this.data == null) {
				this.initArray(this.arrayType);
			}
			this.totalRowsRead = this.width * this.frame;
			this.rowsRead = 0;
			height = this.height;
			while (height--) {
				this.getRow();
			}
			this.frame += 1;
			return this.data;
		};

		Image.prototype.seek = function(frame) {
			if (frame == null) {
				frame = 0;
			}
			if (this.naxis.length === 2) {
				this.totalRowsRead = 0;
				return this.frame = 0;
			} else {
				this.totalRowsRead = this.height * frame;
				return this.frame = this.height / this.totalRowsRead - 1;
			}
		};

		Image.prototype.isDataCube = function() {
			if (this.naxis.length &gt; 2) {
				return true;
			} else {
				return false;
			}
		};

		return Image;

	})(DataUnit);

	this.astro.ASTROFITS.Image = Image;

	Tabular = (function(_super) {

		__extends(Tabular, _super);

		Tabular.dataAccessors = {
			L : function(view) {
				if (view.getInt8() === 84) {
					return true;
				} else {
					return false;
				}
			},
			X : function(view) {
				throw &quot;Data type not yet implemented&quot;;
			},
			B : function(view) {
				return view.getUint8();
			},
			I : function(view) {
				return view.getInt16();
			},
			J : function(view) {
				return view.getInt32();
			},
			K : function(view) {
				var factor, highByte, lowByte, mod, value;
				highByte = Math.abs(view.getInt32());
				lowByte = Math.abs(view.getInt32());
				mod = highByte % 10;
				factor = mod ? -1 : 1;
				highByte -= mod;
				value = factor * ((highByte &lt;&lt; 32) | lowByte);
				console
						.warn(&quot;Something funky happens here when dealing with 64 bit integers.  Be wary!!!&quot;);
				return value;
			},
			A : function(view) {
				return view.getChar();
			},
			E : function(view) {
				return view.getFloat32();
			},
			D : function(view) {
				return view.getFloat64();
			},
			C : function(view) {
				return [view.getFloat32(), view.getFloat32()];
			},
			M : function(view) {
				return [view.getFloat64(), view.getFloat64()];
			}
		};

		function Tabular(view, header) {
			this.getRow = __bind(this.getRow, this);
			Tabular.__super__.constructor.apply(this, arguments);
			this.rowByteSize = header[&quot;NAXIS1&quot;];
			this.rows = header[&quot;NAXIS2&quot;];
			this.cols = header[&quot;TFIELDS&quot;];
			this.length = this.tableLength = this.rowByteSize * this.rows;
			this.rowsRead = 0;
			this.columns = this.getColumnNames(header);
			this.accessors = [];
		}

		Tabular.prototype.getRow = function(row) {
			var accessor, index, _i, _len, _ref;
			if (row == null) {
				row = null;
			}
			if (row != null) {
				this.rowsRead = row;
			}
			this.current = this.begin + this.rowsRead * this.rowByteSize;
			this.view.seek(this.current);
			row = {};
			_ref = this.accessors;
			for (index = _i = 0, _len = _ref.length; _i &lt; _len; index = ++_i) {
				accessor = _ref[index];
				row[this.columns[index]] = accessor();
			}
			this.rowsRead += 1;
			return row;
		};

		Tabular.prototype.getColumnNames = function(header) {
			var columnNames, i, key, _i, _ref;
			columnNames = [];
			for (i = _i = 1, _ref = this.cols; 1 &lt;= _ref
					? _i &lt;= _ref
					: _i &gt;= _ref; i = 1 &lt;= _ref ? ++_i : --_i) {
				key = &quot;TTYPE&quot; + i;
				if (!header.contains(key)) {
					return null;
				}
				columnNames.push(header[key]);
			}
			return columnNames;
		};

		return Tabular;

	})(DataUnit);

	this.astro.ASTROFITS.Tabular = Tabular;

	Table = (function(_super) {

		__extends(Table, _super);

		Table.formPattern = /([AIFED])(\d+)\.*(\d+)*/;

		Table.dataAccessors = {
			A : function(value) {
				return value.trim();
			},
			I : function(value) {
				return parseInt(value);
			},
			F : function(value) {
				return parseFloat(value);
			},
			E : function(value) {
				return parseFloat(value);
			},
			D : function(value) {
				return parseFloat(value);
			}
		};

		function Table(view, header) {
			this.getRow = __bind(this.getRow, this);

			var form, i, match, _fn, _i, _ref, _this = this;
			Table.__super__.constructor.apply(this, arguments);
			_fn = function() {
				var accessor, dataType, decimals, length, _ref1;
				_ref1 = match.slice(1), dataType = _ref1[0], length = _ref1[1], decimals = _ref1[2];
				accessor = function(value) {
					return Table.dataAccessors[dataType](value);
				};
				return _this.accessors.push(accessor);
			};
			for (i = _i = 1, _ref = this.cols; 1 &lt;= _ref
					? _i &lt;= _ref
					: _i &gt;= _ref; i = 1 &lt;= _ref ? ++_i : --_i) {
				form = header[&quot;TFORM&quot; + i];
				match = form.match(Table.formPattern);
				_fn();
			}
		}

		Table.prototype.getRow = function(row) {
			var i, index, line, value, _i, _j, _len, _ref;
			if (row == null) {
				row = null;
			}
			if (row != null) {
				this.rowsRead = row;
			}
			this.current = this.begin + this.rowsRead * this.rowByteSize;
			this.view.seek(this.current);
			line = &quot;&quot;;
			for (i = _i = 1, _ref = this.rowByteSize; 1 &lt;= _ref
					? _i &lt;= _ref
					: _i &gt;= _ref; i = 1 &lt;= _ref ? ++_i : --_i) {
				line += this.view.getChar();
			}
			line = line.trim().split(/\s+/);
			row = {};
			for (index = _j = 0, _len = line.length; _j &lt; _len; index = ++_j) {
				value = line[index];
				row[this.columns[index]] = this.accessors[index](value);
			}
			this.rowsRead += 1;
			return row;
		};

		return Table;

	})(Tabular);

	this.astro.ASTROFITS.Table = Table;

	BinaryTable = (function(_super) {

		__extends(BinaryTable, _super);

		BinaryTable.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

		BinaryTable.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

		function BinaryTable(view, header) {
			var dataType, i, keyword, length, match, value, _i, _ref, _ref1, _this = this;
			BinaryTable.__super__.constructor.apply(this, arguments);
			for (i = _i = 1, _ref = this.cols; 1 &lt;= _ref
					? _i &lt;= _ref
					: _i &gt;= _ref; i = 1 &lt;= _ref ? ++_i : --_i) {
				keyword = &quot;TFORM&quot; + i;
				value = header[keyword];
				match = value.match(BinaryTable.arrayDescriptorPattern);
				if (match != null) {
					(function() {
						var accessor, dataType;
						dataType = match[1];
						accessor = function() {
							var data, length, offset, _j;
							length = _this.view.getInt32();
							offset = _this.view.getInt32();
							_this.current = _this.view.tell();
							_this.view.seek(_this.begin + _this.tableLength
									+ offset);
							data = [];
							for (i = _j = 1; 1 &lt;= length
									? _j &lt;= length
									: _j &gt;= length; i = 1 &lt;= length
									? ++_j
									: --_j) {
								data
										.push(BinaryTable.dataAccessors[dataType](_this.view));
							}
							_this.view.seek(_this.current);
							return data;
						};
						return _this.accessors.push(accessor);
					})();
				} else {
					match = value.match(BinaryTable.dataTypePattern);
					_ref1 = match.slice(1), length = _ref1[0], dataType = _ref1[1];
					length = length ? parseInt(length) : 0;
					if (length === 0 || length === 1) {
						(function(dataType) {
							var accessor;
							accessor = function() {
								var data;
								data = BinaryTable.dataAccessors[dataType](_this.view);
								return data;
							};
							return _this.accessors.push(accessor);
						})(dataType);
					} else {
						(function(dataType, length) {
							var accessor, numBytes;
							if (dataType === 'X') {
								numBytes = Math.log(length) / Math.log(2);
								accessor = function() {
									var bit, bitarray, byte, byte2bits, data, _j, _k, _len;
									byte2bits = function(byte) {
										var bitarray;
										bitarray = [];
										i = 128;
										while (i &gt;= 1) {
											bitarray.push((byte &amp; i ? 1 : 0));
											i /= 2;
										}
										return bitarray;
									};
									data = [];
									for (i = _j = 1; 1 &lt;= numBytes
											? _j &lt;= numBytes
											: _j &gt;= numBytes; i = 1 &lt;= numBytes
											? ++_j
											: --_j) {
										byte = _this.view.getUint8();
										bitarray = byte2bits(byte);
										for (_k = 0, _len = bitarray.length; _k &lt; _len; _k++) {
											bit = bitarray[_k];
											data.push(bit);
										}
									}
									return data.slice(0, +(length - 1) + 1
													|| 9e9);
								};
							} else if (dataType === 'A') {
								accessor = function() {
									var data, _j;
									data = '';
									for (i = _j = 1; 1 &lt;= length
											? _j &lt;= length
											: _j &gt;= length; i = 1 &lt;= length
											? ++_j
											: --_j) {
										data += BinaryTable.dataAccessors[dataType](_this.view);
									}
									return data.trim();
								};
							} else {
								accessor = function() {
									var data, _j;
									data = [];
									for (i = _j = 1; 1 &lt;= length
											? _j &lt;= length
											: _j &gt;= length; i = 1 &lt;= length
											? ++_j
											: --_j) {
										data
												.push(BinaryTable.dataAccessors[dataType](_this.view));
									}
									return data;
								};
							}
							return _this.accessors.push(accessor);
						})(dataType, length);
					}
				}
			}
		}

		return BinaryTable;

	})(Tabular);

	this.astro.ASTROFITS.BinaryTable = BinaryTable;

	Decompress = {
		Rice : function(array, arrayLen, blocksize, bytepix, pixels, nx) {
			var b, bbits, diff, fs, fsbits, fsmax, i, imax, k, lastpix, nbits, nonzeroCount, nzero, pointer, _ref, _ref1;
			bbits = 1 &lt;&lt; fsbits;
			_ref = this.RiceSetup[bytepix](array), fsbits = _ref[0], fsmax = _ref[1], lastpix = _ref[2], pointer = _ref[3];
			nonzeroCount = new Uint8Array(256);
			nzero = 8;
			_ref1 = [128, 255], k = _ref1[0], i = _ref1[1];
			while (i &gt;= 0) {
				while (i &gt;= k) {
					nonzeroCount[i] = nzero;
					i -= 1;
				}
				k = k / 2;
				nzero -= 1;
			}
			nonzeroCount[0] = 0;
			b = array[pointer];
			pointer += 1;
			nbits = 8;
			i = 0;
			while (i &lt; nx) {
				nbits -= fsbits;
				while (nbits &lt; 0) {
					b = (b &lt;&lt; 8) | array[pointer];
					pointer += 1;
					nbits += 8;
				}
				fs = (b &gt;&gt; nbits) - 1;
				b &amp;= (1 &lt;&lt; nbits) - 1;
				imax = i + blocksize;
				if (imax &gt; nx) {
					imax = nx;
				}
				if (fs &lt; 0) {
					while (i &lt; imax) {
						array[i] = lastpix;
						i++;
					}
				} else if (fs === fsmax) {
					while (i &lt; imax) {
						k = bbits - nbits;
						diff = b &lt;&lt; k;
						k -= 8;
						while (k &gt;= 0) {
							b = array[pointer];
							pointer += 1;
							diff |= b &lt;&lt; k;
							k -= 8;
						}
						if (nbits &gt; 0) {
							b = array[pointer];
							pointer += 1;
							diff |= b &gt;&gt; (-k);
							b &amp;= (1 &lt;&lt; nbits) - 1;
						} else {
							b = 0;
						}
						if ((diff &amp; 1) === 0) {
							diff = diff &gt;&gt; 1;
						} else {
							diff = ~(diff &gt;&gt; 1);
						}
						array[i] = diff + lastpix;
						lastpix = array[i];
						i++;
					}
				} else {
					while (i &lt; imax) {
						while (b === 0) {
							nbits += 8;
							b = array[pointer];
							pointer += 1;
						}
						nzero = nbits - nonzeroCount[b];
						nbits -= nzero + 1;
						b ^= 1 &lt;&lt; nbits;
						nbits -= fs;
						while (nbits &lt; 0) {
							b = (b &lt;&lt; 8) | array[pointer];
							pointer += 1;
							nbits += 8;
						}
						diff = (nzero &lt;&lt; fs) | (b &gt;&gt; nbits);
						b &amp;= (1 &lt;&lt; nbits) - 1;
						if ((diff &amp; 1) === 0) {
							diff = diff &gt;&gt; 1;
						} else {
							diff = ~(diff &gt;&gt; 1);
						}
						pixels[i] = diff + lastpix;
						lastpix = pixels[i];
						i++;
					}
				}
			}
			return pixels;
		},
		RiceSetup : {
			1 : function(array) {
				var fsbits, fsmax, lastpix, pointer;
				pointer = 0;
				fsbits = 3;
				fsmax = 6;
				lastpix = array[pointer];
				pointer += 1;
				return [fsbits, fsmax, lastpix, pointer];
			},
			2 : function(array) {
				var bytevalue, fsbits, fsmax, lastpix, pointer;
				pointer = 0;
				fsbits = 4;
				fsmax = 14;
				lastpix = 0;
				bytevalue = array[pointer];
				pointer += 1;
				lastpix = lastpix | (bytevalue &lt;&lt; 8);
				bytevalue = array[pointer];
				pointer += 1;
				lastpix = lastpix | bytevalue;
				return [fsbits, fsmax, lastpix, pointer];
			},
			4 : function(array) {
				var bytevalue, fsbits, fsmax, lastpix, pointer;
				pointer = 0;
				fsbits = 5;
				fsmax = 25;
				lastpix = 0;
				bytevalue = array[pointer];
				pointer += 1;
				lastpix = lastpix | (bytevalue &lt;&lt; 24);
				bytevalue = array[pointer];
				pointer += 1;
				lastpix = lastpix | (bytevalue &lt;&lt; 16);
				bytevalue = array[pointer];
				pointer += 1;
				lastpix = lastpix | (bytevalue &lt;&lt; 8);
				bytevalue = array[pointer];
				pointer += 1;
				lastpix = lastpix | bytevalue;
				return [fsbits, fsmax, lastpix, pointer];
			}
		},
		gzip : function(array) {
			throw &quot;Not yet implemented&quot;;
		},
		plio : function(array, length) {
			throw &quot;Not yet implemented&quot;;
		},
		hcompress : function(array, length) {
			throw &quot;Not yet implemented&quot;;
		}
	};

	this.astro.ASTROFITS.Decompress = Decompress;

	CompressedImage = (function(_super) {

		__extends(CompressedImage, _super);

		CompressedImage.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

		CompressedImage.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

		CompressedImage.include(ImageUtils);

		CompressedImage.extend(Decompress);

		CompressedImage.typedArray = {
			B : Uint8Array,
			I : Int16Array,
			J : Int32Array,
			E : Float32Array,
			D : Float64Array,
			1 : Uint8Array,
			2 : Uint8Array,
			4 : Int16Array,
			8 : Int32Array
		};

		function CompressedImage(view, header) {
			var i, key, value, ztile, _i, _ref;
			CompressedImage.__super__.constructor.apply(this, arguments);
			this.length += header[&quot;PCOUNT&quot;];
			this.zcmptype = header[&quot;ZCMPTYPE&quot;];
			this.zbitpix = header[&quot;ZBITPIX&quot;];
			this.znaxis = header[&quot;ZNAXIS&quot;];
			this.zblank = CompressedImage.setValue(header, &quot;ZBLANK&quot;, void 0);
			this.blank = CompressedImage.setValue(header, &quot;BLANK&quot;, void 0);
			this.ztile = [];
			for (i = _i = 1, _ref = this.znaxis; 1 &lt;= _ref
					? _i &lt;= _ref
					: _i &gt;= _ref; i = 1 &lt;= _ref ? ++_i : --_i) {
				ztile = header.contains(&quot;ZTILE&quot; + i)
						? header[&quot;ZTILE&quot; + i]
						: i === 1 ? header[&quot;ZNAXIS1&quot;] : 1;
				this.ztile.push(ztile);
			}
			this.width = header[&quot;ZNAXIS1&quot;];
			this.height = header[&quot;ZNAXIS2&quot;] || 1;
			this.algorithmParameters = {};
			i = 1;
			while (true) {
				key = &quot;ZNAME&quot; + i;
				if (!header.contains(key)) {
					break;
				}
				value = &quot;ZVAL&quot; + i;
				this.algorithmParameters[header[key]] = header[value];
				i += 1;
			}
			if (this.zcmptype === 'RICE_1') {
				this.setRiceDefaults();
			}
			this.zmaskcmp = CompressedImage
					.setValue(header, &quot;ZMASKCMP&quot;, void 0);
			this.zquantiz = CompressedImage.setValue(header, &quot;ZQUANTIZ&quot;,
					&quot;LINEAR_SCALING&quot;);
			this.bzero = CompressedImage.setValue(header, &quot;BZERO&quot;, 0);
			this.bscale = CompressedImage.setValue(header, &quot;BSCALE&quot;, 1);
			this.defineColumnAccessors(header);
			this.defineGetRow();
		}

		CompressedImage.prototype.defineColumnAccessors = function(header) {
			var accessor, dataType, i, length, match, ttype, value, _i, _ref, _ref1, _results, _this = this;
			this.columnNames = {};
			_results = [];
			for (i = _i = 1, _ref = this.cols; 1 &lt;= _ref
					? _i &lt;= _ref
					: _i &gt;= _ref; i = 1 &lt;= _ref ? ++_i : --_i) {
				value = header[&quot;TFORM&quot; + i];
				match = value.match(CompressedImage.arrayDescriptorPattern);
				ttype = header[&quot;TTYPE&quot; + i].toUpperCase();
				this.columnNames[ttype] = i - 1;
				accessor = null;
				if (match != null) {
					dataType = match[1];
					switch (ttype) {
						case &quot;COMPRESSED_DATA&quot; :
							(function(dataType) {
								return accessor = function() {
									var data, pixels;
									data = _this._accessor(dataType);
									if (data == null) {
										return new Float32Array(_this.ztile[0]);
									}
									pixels = new CompressedImage.typedArray[_this.algorithmParameters[&quot;BYTEPIX&quot;]](_this.ztile[0]);
									CompressedImage
											.Rice(
													data,
													length,
													_this.algorithmParameters[&quot;BLOCKSIZE&quot;],
													_this.algorithmParameters[&quot;BYTEPIX&quot;],
													pixels, _this.ztile[0]);
									return pixels;
								};
							})(dataType);
							break;
						case &quot;UNCOMPRESSED_DATA&quot; :
							(function(dataType) {
								return accessor = _this._accessor(dataType);
							})(dataType);
							break;
						case &quot;GZIP_COMPRESSED_DATA&quot; :
							(function(dataType) {
								return accessor = function() {
									var data, index, item, _j, _len;
									data = _this._accessor(dataType);
									if (data != null) {
										data = new Float32Array(_this.width);
										for (index = _j = 0, _len = data.length; _j &lt; _len; index = ++_j) {
											item = data[index];
											data[index] = NaN;
										}
										return data;
									} else {
										return null;
									}
								};
							})(dataType);
							break;
						default :
							(function(dataType) {
								return accessor = _this._accessor(dataType);
							})(dataType);
					}
				} else {
					match = value.match(CompressedImage.dataTypePattern);
					_ref1 = match.slice(1), length = _ref1[0], dataType = _ref1[1];
					length = length != null ? parseInt(length) : 0;
					if (length === 0 || length === 1) {
						(function(dataType) {
							return accessor = function() {
								return CompressedImage.dataAccessors[dataType](_this.view);
							};
						})(dataType);
					} else {
						(function(length, dataType) {
							return accessor = function() {
								var data, _j, _ref2;
								data = new CompressedImage.typedArray[dataType](length);
								for (i = _j = 0, _ref2 = length - 1; 0 &lt;= _ref2
										? _j &lt;= _ref2
										: _j &gt;= _ref2; i = 0 &lt;= _ref2
										? ++_j
										: --_j) {
									data[i] = CompressedImage.dataAccessors[dataType](_this.view);
								}
								return data;
							};
						})(length, dataType);
					}
				}
				_results.push(this.accessors.push(accessor));
			}
			return _results;
		};

		CompressedImage.prototype.defineGetRow = function() {
			var hasBlanks;
			this.totalRowsRead = 0;
			hasBlanks = (this.zblank != null) || (this.blank != null)
					|| this.columnNames.hasOwnProperty(&quot;ZBLANK&quot;);
			return this.getRow = hasBlanks
					? this.getRowHasBlanks
					: this.getRowNoBlanks;
		};

		CompressedImage.prototype.setRiceDefaults = function() {
			if (!this.algorithmParameters.hasOwnProperty(&quot;BLOCKSIZE&quot;)) {
				this.algorithmParameters[&quot;BLOCKSIZE&quot;] = 32;
			}
			if (!this.algorithmParameters.hasOwnProperty(&quot;BYTEPIX&quot;)) {
				return this.algorithmParameters[&quot;BYTEPIX&quot;] = 4;
			}
		};

		CompressedImage.setValue = function(header, key, defaultValue) {
			if (header.contains(key)) {
				return header[key];
			} else {
				return defaultValue;
			}
		};

		CompressedImage.prototype.getRowHasBlanks = function() {
			var blank, data, index, location, scale, value, zero, _i, _len, _ref;
			_ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
			for (index = _i = 0, _len = data.length; _i &lt; _len; index = ++_i) {
				value = data[index];
				location = this.totalRowsRead * this.width + index;
				this.data[location] = value === blank ? NaN : zero + scale
						* value;
			}
			this.rowsRead += 1;
			return this.totalRowsRead += 1;
		};

		CompressedImage.prototype.getRowNoBlanks = function() {
			var blank, data, index, location, scale, value, zero, _i, _len, _ref;
			_ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
			for (index = _i = 0, _len = data.length; _i &lt; _len; index = ++_i) {
				value = data[index];
				location = this.totalRowsRead * this.width + index;
				this.data[location] = zero + scale * value;
			}
			this.rowsRead += 1;
			return this.totalRowsRead += 1;
		};

		CompressedImage.prototype.getFrame = function() {
			var height;
			if (this.data == null) {
				this.initArray(Float32Array);
			}
			this.totalRowsRead = 0;
			this.rowsRead = 0;
			height = this.height;
			while (height--) {
				this.getRow();
			}
			return this.data;
		};

		CompressedImage.prototype._accessor = function(dataType) {
			var data, i, length, offset, _i, _ref, _ref1;
			_ref = [this.view.getInt32(), this.view.getInt32()], length = _ref[0], offset = _ref[1];
			if (length === 0) {
				return null;
			}
			data = new CompressedImage.typedArray[dataType](length);
			this.current = this.view.tell();
			this.view.seek(this.begin + this.tableLength + offset);
			for (i = _i = 0, _ref1 = length - 1; 0 &lt;= _ref1
					? _i &lt;= _ref1
					: _i &gt;= _ref1; i = 0 &lt;= _ref1 ? ++_i : --_i) {
				data[i] = CompressedImage.dataAccessors[dataType](this.view);
			}
			this.view.seek(this.current);
			return data;
		};

		CompressedImage.prototype._getRow = function() {
			var accessor, blank, data, row, scale, zero, _i, _len, _ref;
			this.current = this.begin + this.totalRowsRead * this.rowByteSize;
			this.view.seek(this.current);
			row = [];
			_ref = this.accessors;
			for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
				accessor = _ref[_i];
				row.push(accessor());
			}
			data = row[this.columnNames[&quot;COMPRESSED_DATA&quot;]]
					|| row[this.columnNames[&quot;UNCOMPRESSED_DATA&quot;]]
					|| row[this.columnNames[&quot;GZIP_COMPRESSED_DATA&quot;]];
			blank = row[this.columnNames[&quot;ZBLANK&quot;]] || this.zblank;
			scale = row[this.columnNames[&quot;ZSCALE&quot;]] || this.bscale;
			zero = row[this.columnNames[&quot;ZZERO&quot;]] || this.bzero;
			return [data, blank, scale, zero];
		};

		CompressedImage.subtractiveDither1 = function() {
			throw &quot;Not yet implemented&quot;;
		};

		CompressedImage.linearScaling = function() {
			throw &quot;Not yet implemented&quot;;
		};

		return CompressedImage;

	})(Tabular);

	this.astro.ASTROFITS.CompressedImage = CompressedImage;

	HDU = (function() {

		function HDU(header, data) {
			this.header = header;
			this.data = data;
		}

		HDU.prototype.hasData = function() {
			if (this.data != null) {
				return true;
			} else {
				return false;
			}
		};

		HDU.prototype.getCard = function(key) {
			return this.header[key];
		};

		return HDU;

	})();

	this.astro.ASTROFITS.HDU = HDU;

	File = (function() {

		File.LINEWIDTH = 80;

		File.BLOCKLENGTH = 2880;

		File.getType = function(obj) {
			return Object.prototype.toString.call(obj).slice(8, -1)
					.toLowerCase();
		};

		function File(buffer) {
			var name;
			name = File.getType(buffer);
			switch (name) {
				case 'arraybuffer' :
					this.initFromBuffer(buffer);
					break;
				case 'object' :
					this.initFromObject(buffer);
					break;
				default :
					throw 'fitsjs cannot initialize object';
			}
		}

		File.excessBytes = function(length) {
			return (File.BLOCKLENGTH - (length % File.BLOCKLENGTH))
					% File.BLOCKLENGTH;
		};

		File.extendDataView = function(view) {
			var getFloat32, getFloat64, getInt16, getInt32, getInt8, getUint16, getUint32, getUint8;
			DataView.prototype.getString = function(length) {
				var c, i, value, _i, _ref;
				value = '';
				for (i = _i = 0, _ref = length - 1; 0 &lt;= _ref
						? _i &lt;= _ref
						: _i &gt;= _ref; i = 0 &lt;= _ref ? ++_i : --_i) {
					c = this.getUint8();
					value += String.fromCharCode(c &gt; 127 ? 65533 : c);
				}
				return value;
			};
			DataView.prototype.getChar = function() {
				return this.getString(1);
			};
			view.offset = 0;
			getInt8 = view.getInt8;
			getUint8 = view.getUint8;
			getInt16 = view.getInt16;
			getUint16 = view.getUint16;
			getInt32 = view.getInt32;
			getUint32 = view.getUint32;
			getFloat32 = view.getFloat32;
			getFloat64 = view.getFloat64;
			view.getInt8 = function() {
				var value;
				value = getInt8.apply(this, [this.offset]);
				this.offset += 1;
				return value;
			};
			view.getUint8 = function() {
				var value;
				value = getUint8.apply(this, [this.offset]);
				this.offset += 1;
				return value;
			};
			view.getInt16 = function() {
				var value;
				value = getInt16.apply(this, [this.offset, false]);
				this.offset += 2;
				return value;
			};
			view.getUint16 = function() {
				var value;
				value = getUint16.apply(this, [this.offset, false]);
				this.offset += 2;
				return value;
			};
			view.getInt32 = function() {
				var value;
				value = getInt32.apply(this, [this.offset, false]);
				this.offset += 4;
				return value;
			};
			view.getUint32 = function() {
				var value;
				value = getUint32.apply(this, [this.offset, false]);
				this.offset += 4;
				return value;
			};
			view.getFloat32 = function() {
				var value;
				value = getFloat32.apply(this, [this.offset, false]);
				this.offset += 4;
				return value;
			};
			view.getFloat64 = function() {
				var value;
				value = getFloat64.apply(this, [this.offset, false]);
				this.offset += 8;
				return value;
			};
			view.seek = function(offset) {
				return this.offset = offset;
			};
			return view.tell = function() {
				return this.offset;
			};
		};

		File.prototype.initFromBuffer = function(buffer) {
			var data, hdu, header, _results;
			this.length = buffer.byteLength;
			this.view = new DataView(buffer);
			this.hdus = [];
			this.eof = false;
			File.extendDataView(this.view);
			_results = [];
			while (true) {
				header = this.readHeader();
				data = this.readData(header);
				hdu = new HDU(header, data);
				this.hdus.push(hdu);
				if (this.eof) {
					break;
				} else {
					_results.push(void 0);
				}
			}
			return _results;
		};

		File.prototype.initFromObject = function(buffer) {
			this.length = buffer.length;
			this.view = null;
			this.hdus = buffer.hdus;
			return this.eof = true;
		};

		File.prototype.readHeader = function() {
			var beginOffset, block, done, end, endOffset, endPattern, header, i, line, match, start, whitespacePattern;
			whitespacePattern = /\s{80}/;
			endPattern = /^END\s/;
			beginOffset = this.view.tell();
			done = false;
			while (true) {
				if (done) {
					break;
				}
				block = this.view.getString(File.BLOCKLENGTH);
				i = 0;
				while (true) {
					start = File.BLOCKLENGTH - File.LINEWIDTH * (i + 1);
					end = File.BLOCKLENGTH - File.LINEWIDTH * i;
					line = block.slice(start, end);
					match = line.match(whitespacePattern);
					if (match) {
						i += 1;
						continue;
					}
					match = line.match(endPattern);
					if (match) {
						endOffset = this.view.tell();
						this.view.seek(beginOffset);
						block = this.view.getString(endOffset - beginOffset);
						header = new Header();
						header.init(block);
						done = true;
						this.checkEOF();
						return header;
					}
					break;
				}
			}
		};

		File.prototype.readData = function(header) {
			var data, excess;
			if (!header.hasDataUnit()) {
				return;
			}
			if (header.isPrimary()) {
				data = new Image(this.view, header);
			} else if (header.isExtension()) {
				if (header.extensionType === &quot;BINTABLE&quot;) {
					if (header.contains(&quot;ZIMAGE&quot;)) {
						data = new CompressedImage(this.view, header);
					} else {
						data = new BinaryTable(this.view, header);
					}
				} else if (header.extensionType === &quot;TABLE&quot;) {
					data = new Table(this.view, header);
				} else if (header.extensionType === &quot;IMAGE&quot;) {
					data = new Image(this.view, header);
				}
			}
			excess = File.excessBytes(data.length);
			this.view.seek(this.view.tell() + data.length + excess);
			this.checkEOF();
			return data;
		};

		File.prototype.checkEOF = function() {
			if (this.view.offset &gt;= this.length) {
				return this.eof = true;
			}
		};

		File.prototype.count = function() {
			return this.hdus.length;
		};

		File.prototype.getHDU = function(index) {
			var hdu, _i, _len, _ref;
			if (index == null) {
				index = void 0;
			}
			if ((index != null) &amp;&amp; (this.hdus[index] != null)) {
				return this.hdus[index];
			}
			_ref = this.hdus;
			for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
				hdu = _ref[_i];
				if (hdu.hasData()) {
					return hdu;
				}
			}
		};

		File.prototype.getHeader = function(index) {
			if (index == null) {
				index = void 0;
			}
			return this.getHDU(index).header;
		};

		File.prototype.getDataUnit = function(index) {
			if (index == null) {
				index = void 0;
			}
			return this.getHDU(index).data;
		};

		File.prototype.getData = function(index) {
			if (index == null) {
				index = void 0;
			}
			return this.getHDU(index).data.getFrame();
		};

		return File;

	})();

	this.astro.ASTROFITS.File = File;

}).call(this);
</pre>
</body>
</html>
